#+TITLE: KESS - Keep Emacs Simple, Stupid!
#+STARTUP: content
#+OPTIONS: toc:4 h:4

* Preface
OK, the following configuration as *simple* as promised, but I'm trying
achieve this goal as I'm getting more comfortable with emacs.

Also, I'm trying to make KESS work as I expect on all my OSs:
- Win7/Win10 (chocolatey emacs package)
- Debian/Ubuntu (apt-get emacs package)
- Arch Linux (pacman emacs package)
* Personal information
I got this [[https://github.com/sachac/.emacs.d][org-babel config]] idea from [[https://github.com/sachac][Sacha Chua]] and her [[http://sachachua.com/blog/][amazing blog]].
Thanks Sacha!
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Tiefeng Wu"
        user-mail-address "icebergwtf@qq.com")
#+END_SRC
* Setup load paths
#+BEGIN_SRC emacs-lisp
  (let ((home-lib-path (expand-file-name "~/.elisp/")))
    (when (file-directory-p home-lib-path)
      (add-to-list 'load-path home-lib-path)
      (load (concat home-lib-path "init.el") 'noerror)))
#+END_SRC
* Package Setup
** package.el
Setup archive lists and initialize package.el
#+BEGIN_SRC emacs-lisp
  ;; package.el setup

  ;; helper functions
  (defun kess/add-to-package-archives (name url &optional overwrite append)
    (if (assoc name package-archives)
        (when overwrite
          (setcdr (assoc name package-archives) url))
      (add-to-list 'package-archives (cons name url) append)))

  (defun kess/insert-to-package-archives (name url &optional overwrite)
    (kess/add-to-package-archives name url overwrite))

  (defun kess/append-to-package-archives (name url &optional overwrite)
    (kess/add-to-package-archives name url overwrite 'append))

  ;; add archives to package-archives, if not exist
  (let* ((schema (or (and (gnutls-available-p)  "https://") "http://")))
    (kess/append-to-package-archives "gnu" (concat schema "elpa.gnu.org/packages/"))
    (kess/append-to-package-archives "melpa" (concat schema "melpa.org/packages/"))
    (kess/append-to-package-archives "marmalade" (concat schema "marmalade-repo.org/packages/")))

  (kess/append-to-package-archives "org" "http://orgmode.org/elpa/")

  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC
** use-package
[[https://github.com/jwiegley/use-package][use-package]] is very handy for package management, also I use bind-key to define
my own key bindings.
#+BEGIN_SRC emacs-lisp
  ;; use-package setup
  (unless (package-installed-p 'use-package)
    (unless (assoc 'use-package package-archive-contents)
      (package-refresh-contents))
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package)
    (setq use-package-always-ensure t
          use-package-verbose t))

  ;; packages that use-package recommend
  (use-package diminish)
  (use-package bind-key)
#+END_SRC
* Default Setup
** better-defaults
Use [[https://github.com/technomancy/better-defaults][better-defaults]] package as start point
#+BEGIN_SRC emacs-lisp
(use-package better-defaults)
#+END_SRC
** emacs apperence
Load faviorite theme, and since I'm still an emacs newbie, I perfer to enable
menu bar under GUI mode, whenever I'm getting lost, menu bar come for rescue.
#+BEGIN_SRC emacs-lisp
  (load-theme 'tango-dark)
  (when window-system
    (menu-bar-mode 1)
    (if (equal system-type 'windows-nt)
        (add-hook 'after-init-hook 'toggle-frame-maximized)
      (add-hook 'after-init-hook 'toggle-frame-fullscreen)))
#+END_SRC
* My defaults
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4
                indent-tabs-mode nil
                show-trailing-whitespace t)

  (setq inhibit-startup-screen t
        gc-cons-threshold 20000000
        gdb-many-windows t
        default-fill-column 80
        highlight-nonselected-windows t
        scroll-conservatively 9999
        scroll-margin 5
        scroll-step 1
        system-time-locale "C"
        tramp-default-method "ssh"
        diff-switches "-u"
        split-width-threshold 120
        split-height-threshold 40)

  (setq org-catch-invisible-edits 'smart
        org-completion-use-ido t
        org-ctrl-k-protect-subtree t
        org-enforce-todo-checkbox-dependencies t
        org-enforce-todo-dependencies t
        org-log-done 'time
        org-return-follows-link t
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        org-special-ctrl-o t
        org-startup-indented t
        org-use-property-inheritance t)

  (winner-mode 1)
  (show-paren-mode 1)
  (recentf-mode 1)
  (column-number-mode 1)
  (savehist-mode 1)

  (setq display-time-24hr-format t
        display-time-day-and-date t)
  (display-time-mode 1)

  (setq linum-format "%4d")
  (global-linum-mode 1)

  (setq desktop-restore-frames nil
        desktop-restore-eager 10
        desktop-save t
        desktop-base-file-name "desktop"
        desktop-path user-emacs-directory
        desktop-dirname user-emacs-directory)
  (desktop-save-mode 1)
#+END_SRC
* Essential packages
These're packages I think is essential.
** undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree :config (global-undo-tree-mode))
#+END_SRC
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :demand
    :bind (:map company-active-map
                ("M-n" . company-next-page)
                ("M-p" . company-previous-page)
                ("C-n" . company-select-next-or-abort)
                ("C-p" . company-select-previous-or-abort))
    :config
    (setq company-idle-delay 0.3
          company-tooltip-limit 12
          company-minimum-prefix-length 2)
    (global-company-mode 1))
#+END_SRC
** ido
#+BEGIN_SRC emacs-lisp
  (use-package ido-ubiquitous :defer t)

  (use-package flx-ido
    :defer t
    :config
    (setq ido-enable-prefix nil
          ido-enable-flex-matching t
          ido-use-faces nil
          ido-create-new-buffer 'always
          ido-use-filename-at-point 'guess
          ido-max-prospects 10
          ido-default-file-method 'selected-window
          ido-auto-merge-work-directories-length -1)
    (flx-ido-mode 1))
#+END_SRC
** ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand
    :ensure counsel
    :diminish ivy-mode
    :bind (:map ivy-minibuffer-map
                ("C-j" . ivy-immediate-done)
                ("RET" . ivy-alt-done))
    :bind (:map read-expression-map
                ("C-r" . counsel-expression-history))
    :config
    (add-hook 'after-init-hook
              (lambda ()
                (when (bound-and-true-p ido-ubiquitous-mode)
                  (ido-ubiquitous-mode -1))
                (when (bound-and-true-p ido-mode)
                  (ido-mode -1))
                (ivy-mode 1)))

    (setq-default ivy-use-virtual-buffers t
                  ivy-count-format ""
                  ivy-initial-inputs-alist '((man . "^") (woman . "^"))
                  projectile-completion-system 'ivy)
    (setq ivy-use-virtual-buffers t
          enable-recursive-minibuffers t)

    (use-package ivy-historian
      :config
      (add-hook 'after-init-hook (lambda () (ivy-historian-mode t)))))
#+END_SRC
* Useful packages
In order to be KESS, these're packages besides essential packages
loaded above.
#+BEGIN_SRC emacs-lisp
  (use-package ag :defer t)
  (use-package ack :defer t)
  (use-package bookmark+ :defer t)
  (use-package cl-lib :config (require 'cl-lib))
  (use-package dtrt-indent :config (dtrt-indent-mode 1))
  (use-package fullframe :config (fullframe list-packages quit-window))
  (use-package smex :defer t)
  (use-package popwin :config (popwin-mode 1))
#+END_SRC
* Evil-mode
Use advice to escape from insert mode, to just use evil normal and
visual states, for editing tasks, e.g. insert state, use regular
emacs. /Don't know if this really possible./
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :diminish undo-tree-mode
    :config
    (unbind-key "C-z" evil-normal-state-map)
    (unbind-key "C-z" evil-motion-state-map)
    (unbind-key "C-z" evil-insert-state-map)

    (setq evil-esc-delay 0)

    (use-package evil-visualstar
      :config
      (global-evil-visualstar-mode t))

    (use-package evil-leader
      :config
      (setq evil-leader/in-all-states 1)
      (evil-leader/set-leader ",")
      (global-evil-leader-mode)
      (evil-leader/set-key "/" 'evil-search-highlight-persist-remove-all)))

  (use-package evil-numbers
    :demand
    :bind (:map evil-normal-state-map
                ("+" . evil-numbers/inc-at-pt)
                ("-" . evil-numbers/dec-at-pt)))

  (use-package evil-search-highlight-persist
    :config
    (global-evil-search-highlight-persist t))
#+END_SRC
* Coding setup
** Syntax Check
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :defer t
    :diminish flycheck-mode
    :config
    (use-package flycheck-pos-tip)
    (when (display-graphic-p (selected-frame))
      (eval-after-load 'flycheck
        '(custom-set-variables
          '(flycheck-display-errors-function #'flycheck-pos-tip-error-messages)))))
#+END_SRC
** Templating
Learn more and get used to it.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :defer t
    :diminish yas-minor-mode
    :config
    (setq yas-snippet-dirs (concat user-emacs-directory "snippets"))
    (yas-global-mode 1))
#+END_SRC
** Lisp coding setup
:PROPERTIES: 
:CUSTOM_ID: paredit
:END:
#+BEGIN_SRC emacs-lisp
  (defun add-lisp-hook (func)
    (dolist (x '(scheme emacs-lisp lisp clojure lisp-interaction slime-repl cider-repl))
      (add-hook (intern (concat (symbol-name x) "-mode-hook")) func)))
#+END_SRC
*** clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode :defer t)
  (use-package cider :defer t)
#+END_SRC
*** common lisp
#+BEGIN_SRC emacs-lisp
(load (expand-file-name "~/quicklisp/slime-helper.el"))
(setq inferior-lisp-program "sbcl")
#+END_SRC
*** paredit
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :demand
    :diminish paredit-mode
    :bind (:map paredit-mode-map
                ("C-." . paredit-forward-slurp-sexp)
                ("C-," . paredit-forward-barf-sexp)
                ("C-\>" . paredit-backward-barf-sexp)
                ("C-\<" . paredit-backward-slurp-sexp))
    :config
    (add-lisp-hook 'enable-paredit-mode))
#+END_SRC
*** emacs-lisp
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("Cask"  . emacs-lisp-mode))

  (use-package eldoc
    :diminish eldoc-mode
    :config
    (eldoc-add-command 'paredit-backward-delete 'paredit-close-round)
    (add-lisp-hook (lambda () (eldoc-mode 1))))
#+END_SRC
** Ruby coding setup
#+BEGIN_SRC emacs-lisp
  (use-package ruby-mode
    :bind (:map ruby-mode-map
                ("TAB" . indent-for-tab-command))
    :config
    (setq-default ruby-use-encoding-map nil
                  ruby-insert-encoding-magic-comment nil)

    (add-hook 'ruby-mode-hook
              (lambda ()
                (unless (derived-mode-p 'prog-mode)
                  (run-hooks 'prog-mode-hook))))
    (add-hook 'ruby-mode-hook 'subword-mode)

    (use-package ruby-hash-syntax)
    (use-package ruby-compilation
      :config
      (defalias 'rake 'ruby-compilation-rake))
    (use-package inf-ruby)
    (use-package robe
      :config
      (eval-after-load 'company '(push 'company-robe company-backends))
      (add-hook 'robe-mode-hook 'ac-robe-setup)
      (add-hook 'ruby-mode-hook 'robe-mode))

    (use-package rspec-mode)
    (use-package yari
      :config
      (defalias 'ri 'yari))
    (use-package goto-gem)
    (use-package bundler)
    (use-package yaml-mode)
    (use-package mmm-mode
      :config
      (require 'mmm-erb)
      (require 'derived)
      (mmm-add-mode-ext-class 'html-erb-mode "\\.jst\\.ejs\\'" 'ejs)

      (add-to-list 'auto-mode-alist '("\\.jst\\.ejs\\'"  . html-erb-mode))
      (mmm-add-mode-ext-class 'yaml-mode "\\.yaml\\(\\.erb\\)?\\'" 'erb)))
#+END_SRC
** C# coding setup
More dig into omnisharp-emacs.
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode :defer t)
  (use-package omnisharp
    :defer t
    :config
    (setq omnisharp-server-executable-path "~/bin/omnisharp/OmniSharp")
    (when (file-exists-p omnisharp-server-executable-path)
      (add-hook 'csharp-mode-hook 'omnisharp-mode)
      (add-to-list 'company-backends 'company-omnisharp)))
#+END_SRC
** Common coding setup
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-lisp-hook 'rainbow-delimiters-mode))

  (use-package color-identifiers-mode
    :diminish color-identifiers-mode
    :config
    (global-color-identifiers-mode))
#+END_SRC
* Project management
Just start to use them, maybe one of both is enough? Or maybe a wrapper package
to benefit from both? (Another tough task)
** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand
    :config
    (projectile-global-mode)
    (setq projectile-indexing-method 'alien
          projectile-enable-caching t))
#+END_SRC
** find-file-in-project
#+BEGIN_SRC emacs-lisp
  (use-package find-file-in-project :ensure ivy)
#+END_SRC
** find-file-in-repository
#+BEGIN_SRC emacs-lisp
  (use-package find-file-in-repository)
#+END_SRC
* Emacs server
Start server if not already running. Properly set server to work on MSWin is
painful.
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (require 'server)
              (unless (server-running-p)
                (server-start))))
#+END_SRC
* Custom prefix keymap
To not mess up with emacs's own and other package's prefix maps, my
custom prefix binding use C-\, which I think very easy to reach.
#+BEGIN_SRC emacs-lisp
  ;; C-\ prefix map for nearly all my custom bindings, to not mess up
  ;; default or other installed package's bindings
  (define-prefix-command 'kess-prefix-map)
  (bind-key* (kbd "C-\\") kess-prefix-map)
  (bind-keys :map kess-prefix-map
             ("0" . delete-frame)

             ("a" . counsel-ag)
             ("f" . flycheck-mode)
             ("g" . counsel-git)
             ("j" . counsel-git-grep)
             ("l" . counsel-locate)
             ("o" . counsel-rhythmbox)
             ("r" . ivy-resume)
             ("s" . swiper)
             ("z" . org-archive-to-archive-sibling)

             ("," . winner-undo)
             ("." . winner-redo)
             ("/" . comment-region)
             ("\\" . uncomment-region)

             ("C-." . describe-personal-keybindings)
             ("C-\\" . evil-search-highlight-persist-remove-all)

             ("M-x" . execute-extended-command)
             ("M-X" . smex-major-mode-commands)

             ("TAB" . org-force-cycle-archived)
             ("ESC" . evil-mode))
#+END_SRC
* Global bindings
** Utility functions
#+BEGIN_SRC emacs-lisp
  (defun kess/switch-buffer (next)
    "Switch to non *[buffer]* buffer, use next-buffer when NEXT is t,
      otherwise, previous-buffer. (idea from stackoverflow)

  Some of *[buffer]* are included to switching, like *scratch*, *info*, etc."
    (let ((bread-crumb (buffer-name))
          (fn (or (and next 'next-buffer) 'previous-buffer))
          (allowed-buffers '("*scratch*" "*info*" "*eshell*")))
      (funcall fn)
      (while (and (not (equal bread-crumb (buffer-name)))
                  (and (not (member (buffer-name) allowed-buffers))
                       (string-match-p "^\*.*\*$" (buffer-name))))
        (funcall fn))))

  (defun kess/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (indent-region (point-min) (point-max) nil))

  (defun kess/kill-current-buffer ()
    "Kill current buffer."
    (interactive)
    (kill-buffer (get-buffer (buffer-name))))
#+END_SRC
** Bindings
#+BEGIN_SRC emacs-lisp
  (bind-keys ("<backspace>" . delete-backward-char)
             ("M-n" . scroll-up-command)
             ("M-N" . scroll-other-window)
             ("M-p" . scroll-down-command)
             ("M-P" . scroll-other-window-down)
             ("C-M-." . scroll-up-line)
             ("C-M-," . scroll-down-line)
             :map Info-mode-map
             ("<backspace>" . Info-scroll-down))

  (bind-keys* ("M-H" . eval-buffer)
              ("M-o" . find-file-in-project)
              ("M-O" . find-file-in-repository)
              ("M-D" . find-file-in-current-directory)
              ("M-x" . counsel-M-x)
              ("M-X" . smex)
              ("M-\\" . hippie-expand)
              ("M-`" . kess/kill-current-buffer)

              ("C-;" . mark-sexp)
              ("C-'" . set-mark-command)

              ("C-v" . yank)
              ("C-z" . undo-tree-undo)
              ("C-y" . undo-tree-redo)
              ("C-/" . swiper)

              ("C-M-x" . eval-defun)
              ("C-M-z" . eval-region)

              ("C-x C-f" . counsel-find-file)
              ("C-x S" . write-file)

              ("C-S-g" . occur)
              ("C-S-s" . save-some-buffers)

              ("<C-tab>" . (lambda () (interactive) (kess/switch-buffer t)))
              ("<C-S-tab>" . (lambda () (interactive) (kess/switch-buffer nil)))
              ("<C-iso-lefttab>" . (lambda () (interactive) (kess/switch-buffer t)))
              ("<C-S-iso-lefttab>" . (lambda () (interactive) (kess/switch-buffer nil)))

              ("C-M-|" . kess/indent-buffer)
              ("C-+" . evil-numbers/inc-at-pt)
              ("C-_" . evil-numbers/dec-at-pt)
              ("C-:" . evil-ex)

              ("C-M-h" . windmove-left)
              ("C-M-j" . windmove-down)
              ("C-M-k" . windmove-up)
              ("C-M-l" . windmove-right)

              ("C-M-/" . query-replace)
              ("C-M-?" . query-replace-regexp)

              ("C-h n" . counsel-find-library)
              ("C-h N" . view-emacs-news)

              ("C-h h" . counsel-info-lookup-symbol)
              ("C-h H" . view-hello-file)

              ("C-h t" . counsel-unicode-char)
              ("C-h T" . help-with-tutorial))
#+END_SRC
